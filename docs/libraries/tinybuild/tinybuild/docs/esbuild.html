<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brains@Play Docs</title>
    <style>
* {
  box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
    height: 100vh;
    width: 100vw;
}

body {
  padding: 0px 50px;
}
</style>
    <link rel=stylesheet href="../../../../static/custom.css"/>
    <link rel="icon" href="../../../../static/img/favicon.ico" type="image/x-icon" />
</head>
<body>
    <nav></nav>
    <h2 id="esbuildhttpsesbuildgithubio"><a href="https://esbuild.github.io/">esbuild</a></h2>
<p>esbuild is an ultra lightweight and fast bundler (based in Rust) used in NodeJS to compile javascript projects. It works using Nodejs and can bundle any javascript and typescript projects generically like other bundlers. It typically takes &lt;100ms to bundle a javascript project, and about 2 seconds if you add the type generation plugin.</p>
<p>esbuild supports the full spectrum of javascript bundling needs we've encountered so far and we have documented and abstracted its typical features fairly well with our settings. See their website for more information. </p>
<p>Code: <a href="../esbuild"><code>tinybuild/esbuild</code></a></p>
<h2 id="bundling">Bundling</h2>
<p>Create an index.js (or whatever name) file serving as the entry point script for your webapp or library e.g.:</p>
<pre><code class="js language-js">if(typeof window !== 'undefined') alert('Tinybuild successful!')
console.log('Tinybuild succesful!')
</code></pre>
<p>Now create a bundler.js file which we'll execute with <code>node bundler.js</code></p>
<pre><code class="js language-js">import {bundle} from 'tinybuild'

bundle({
    entryPoints: ['index.js'],
    outfile: 'dist/index',
    bundleBrowser: true, //plain js format
    bundleESM: false, //.esm format
    bundleTypes: false, //you need a .tsconfig for this to work
    bundleHTML: true
})
</code></pre>
<p>Our presets will let you quickly bundle apps, browser and node modules, generate types, create "executable" html files from entry points, "webpacked" globals and init scripts, and more with esbuild (minification, sourcemaps, js or browser version targeting, etc.), all with just one input object!</p>
<p>The other half of our preset tools in tinybuild include a boilerplate node development server with optional https, hot reloading, pwa support, python server interoperation examples, and websocket presets so it can work as a quick and dirty production server as well.</p>
<h2 id="bundlersettings">Bundler settings</h2>
<p>Any unlisted settings are just typical esbuild settings, which can be configured per build type via the .options tag (e.g. config.options.browser = {…more esbuild settings})</p>
<pre><code class="js language-js">//found in esbuild/bundler.js
const bundlerSettings = {
  bundleBrowser:true, //create plain js build? Can include globals and init scripts
  bundleESM:false,     //create esm module js files
  bundleTypes:false,   //create .d.ts files, //you need a .tsconfig for this to work
  bundleNode:false,   //create node platform plain js build, specify platform:'node' to do the rest of the files 
  bundleIIFE:false,   //create an iife build, this is compiled temporarily to create the types files
  bundleCommonJS:false, //cjs format outputted as .cjs
  bundleHTML:false,   //wrap the first entry point file as a plain js script in a boilerplate html file, frontend scripts can be run standalone like a .exe!
  entryPoints:['index.ts'], //entry point file(s). These can include .js, .mjs, .ts, .jsx, .tsx, or other javascript files. Make sure your entry point is a ts file if you want to generate types
  outfile:'dist/index',     //exit point file, will append .js as well as indicators like .esm.js, .node.js for other build flags
  //outdir:[]               //exit point files, define for multiple bundle files
  bundle:true,
  platform: 'browser', //'node' //bundleNode will use 'node' mode by default
  minify: true,
  sourcemap: false,
  external: ['node-fetch'], // []; //we use node-fetch a lot
  allowOverwrite:true, 
  loader: {
    '.html': 'text', //not always necessary but it doesn't hurt
    '.png' : 'file',
    '.jpg' : 'file',
    '.gif' : 'file',
    '.svg': 'file',
    '.woff': 'file',
    '.woff2': 'file',
    '.ttf': 'file',
    '.eot': 'file',
    '.mp3': 'file',
    '.mp4': 'file',
    '.json': 'text',
  },
  outputs:{ //overwrites main config settings for specific use cases, you can also set the bundleBrowser etc.. settings to these objects
    node:{ 
      external:[] //externals for node environment builds
    }
    //esm:{}
    //commonjs:{}
    //browser:{}
    //iife:{}
  }
  //globalThis:null //'brainsatplay'
  //globals:{['index.ts']:['Graph']}
  //init:{['index.ts']:function(bundle) { console.log('prepackaged bundle script!', bundle); }.toString() }
}
//the rest are based on what esbuild offers
</code></pre>
<h3 id="browserbundling">Browser Bundling</h3>
<p>Browser bundling simply breaks projects down into plain js format, usable e.g. in script tags. </p>
<p>This includes support for setting module global names as well as specifying specific class names or functions, variables, etc you want to expose via the <code>globalThis:string</code> and <code>globals:{'entryPoints.js':['ClassToSetOnglobalThis']}</code> settings. </p>
<p>The <code>init:{'entryPoints.js':function(bundle){}}</code> setting lets you specify scripts to append to bundles e.g. to initialize bundled class instances with default settings. It's painless! Currently these extra settings only apply to the browser bundle, which you could override to format for esm via .outputs.browser.format = 'esm' or .outputs.browser.platform = 'node'.</p>
<h3 id="esmbundling">ESM Bundling</h3>
<p>ESM bundles are for enabling the <code>import</code>/<code>export</code> syntax either in es6 or later javascript environments. Default scripts in browsers or nodejs do not support <code>import</code>/<code>export</code>. </p>
<h3 id="typesbundling">Types Bundling</h3>
<p>You need a tsconfig in your project root for this to work, we edited the plugin to work with any js/jsx/ts/tsx entry points. </p>
<p>These function sort of like header files in strongly-typed C, which show you all of the functions/classes/variables/etc. and their expected input/output formats (including detailed formatting for objects or array types) in each respective script file. Nice for reference, VSCode otherwise does this on-the-fly even in .js files when working.</p>
<h3 id="nodebundling">Node Bundling</h3>
<p>This is a setting to generate a plain js file with <code>platform:'node'</code> targeted. If you include this setting in the bundler settings object it will apply to all bundles. It allows node modules like <code>fs</code> or <code>ws</code> etc. to be bundled as needed. </p>
<p>We use it in some cases to create frontend and backend libraries from the same files that otherwise use the same function calls just with different dependencies if running a client or server, as browsers lack backend server libraries and node lacks frontend tools like animations or the DOM (without an engine anyway). </p>
<h3 id="iifecommonjs">IIFE/CommonJS</h3>
<p>These are other bundle formats. We temporarily generate IIFE files so the types plugin runs correctly but it isn't saved unless specified. </p>
<h3 id="htmlbundling">HTML Bundling</h3>
<p>This is an extension to the browser bundler (including the global installs) that will wrap the browser bundle in HTML boilerplate. </p>
<p>If your script entry point is to your app, then this can automatically be served, and if the app does not require served files etc. then it essentially serves like a built .exe file. </p>
<p>You may also use it if you want to write quick library or frontend tests with init scripts and test serving scripts to execute in-browser. Currently this test setting only applies to the browser bundle, which you could override to format for esm via .outputs.browser.format = 'esm' or .outputs.browser.platform = 'node'. </p>
<h3 id="workerbundling">Worker bundling</h3>
<p>This custom plugin is active by default. The only prerequisite is that your worker files have 'worker.js' or '.worker' (e.g. for ts worker files) in their path. Then import your workers like this:</p>
<pre><code class="js language-js">import worker from 'worker.js' //or if the worker is a ts file, '.worker' will resolve the separate worker bundle too
//export { worker } //you can re-export the bundled worker blob/path or use it in your app/library

let w = new Worker(worker);
</code></pre>
<p>And esbuild will bundle the worker with your distribution! You'll find the bundled workers in the same output file location. You can bundle workers directly in your app/library using our plugin (applied by default) which bundles and inserts the worker code as an inline object url. </p>
<p>If you set the blobWorkers setting to false using the workerPlugin manually in your config, it will supply the expected url to the server's node_modules folder when you install the worker library. You can set the bundler settings for the worker in the workerPlugin initialization as well, it defaults to only setting <code>minifyWhitespace:true</code> in the bundler settings. </p>
<p>Find our <a href="https://github.com/brainsatplay/graphscript/examples">graphscript</a> examples for multiple worker implementations for graphics rendering with threejs.</p>
<h3 id="external">External</h3>
<p>For modules including node libraries that are meant to interoperate with the browser, make sure you exclude them in via the 'external' setting.</p>
<h3 id="outputs">Outputs</h3>
<p>To specify specific bundler settings (overwriting the main object), set e.g. settings.bundleESM OR settings.outputs.esm = { …more<em>esbuild</em>settings }. Node by default has its own 'external' setting for example so it can include any node modules excluded for browser bundling otherwise.</p>
<h3 id="andmore">And More!</h3>
<p>esbuild doesn't have the greatest documentation. You could say there's a lot to… unpack… Anyway, go crazy! This is the best bundler we've used! We've compensated for esbuild's lack of umd support with our globals settings. No complaints so far!</p>
    <footer></footer>
</body>
</html>