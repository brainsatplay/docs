<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brains@Play Docs</title>
    <style>
* {
  box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
}

body {
  padding: 0px 50px;
}
</style>
    <link rel=stylesheet href="../../../../static/custom.css"/>
    <link rel="icon" href="../../../../static/img/favicon.ico" type="image/x-icon" />
</head>
<body>
    <nav></nav>
    <h1 id="routers">Routers</h1>
<p>Routers extend Services with a uniform networking layer to pool templated service connections based on services and arbitrary source ids. This includes convenience features for adding and removing users from the system in a self-cleaning fashion (when using the defaults) so you can quickly make multi-tiered server and peer-2-peer communication schemes.</p>
<p>See <code>examples/webrtcrouter</code> for a robust example that implements a backend with server-sent events, websockets, hot reloading, and a frontend for sharing webrtc peer connections mediated by the socket server - all in less than 500 lines of code! The Frontend-Backend and the Peer-Peer connections are handled with the exact same callbacks, only specifying different endpoint ids! This allows for remote controls and multi-user contexts with the smoothest code you've ever seen! </p>
<h4 id="routeroptions">Router Options</h4>
<p>Routers have additional important options on top of the base service. They otherwise function exactly like a service, where any service can load any other service, but give an additional layer of control to how services are named, configured, and referenced in your program, as well as the macros for user and general remote networking graphs.</p>
<pre><code class="ts language-ts">export type RouterOptions = ServiceOptions &amp; {
    services?:{
        [key:string]:Service|any|{
            service:Service|any,
            connections:string[]|{[key:string]:any},
            config?:{ //configure connections per service
                [key:string]:{ //configure multiple connection instances using the generic 'open' function
                    _id?:string,
                    source?:string,
                    onclose?:(c:ConnectionInfo,...args:any[])=&gt;void,
                    args?:any[], //other arguments a service spec expects other than the main config object (try to make it just one object for easier config automation!)
                    [key:string]:any //configuration settings
                }
            }, //configure new connections after adding the relevant services?
        } //can be a service constructor
    }
    syncServices?:boolean,
    order?:string[]
}
</code></pre>
<h4 id="connectiontemplateschema">Connection Template Schema</h4>
<p>Any service can have a 'connections' object for storing connections or multiple groups of connections (e.g. socket servers in one group and all of the client sockets in another group) that the Router can look for automatically to pool connections that are then available by id for tying to different sources. It makes it a series of one-liners to configure a full endpoint systems and subscriptions through connections to events on programs across clients and servers. </p>
<pre><code class="ts language-ts">type ConnectionTemplate = {
    _id?:string,
    send?:(message:any, ...args:any[])=&gt;any,
    request?:(message:any, method?:any,...args:any[])=&gt;Promise&lt;any&gt;|Promise&lt;any&gt;[],
    post?:(route:any, args?:any, method?:string, ...args:any[])=&gt;void,
    run?:(route:any, args?:any, method?:string, ...args:any[])=&gt;Promise&lt;any&gt;|Promise&lt;any&gt;[],
    subscribe?:(route:any, callback?:((res:any)=&gt;void)|string, ...args:any[])=&gt;Promise&lt;number&gt;|Promise&lt;number&gt;[]|undefined,
    unsubscribe?:(route:any, sub:number, ...args:any[])=&gt;Promise&lt;boolean&gt;|Promise&lt;boolean&gt;[],
    terminate:(...args:any[]) =&gt; boolean,
}
</code></pre>
<p>The current templates exist based on the frontend and backend (respective) remote endpoint services we've constructed so far:</p>
<pre><code class="ts language-ts">type WebRTCInfo; //rtc
type WebSocketInfo; //browser ws
type SocketInfo; //node ws, incl wss clients
type SocketServerInfo; //node wss
type SSEChannelInfo; //node sse
type SSESessionInfo; //node sse client-specific
type EventSourceInfo; //browser sse
type ServerInfo;    //node http/https server
</code></pre>
<p>Or use any Graphs or GraphNodes to wrap with the template functions, these can then handle local transmission or be a quick proxy to other connections you want to add yourself without implementing a Service.</p>
<p>Now add a connection with <code>addConnection</code> or use the router constructor options to do it all in one shot with each service specified</p>
<pre><code class="ts language-ts">router.addConnection(options:ConnectionProps|ConnectionInfo|string,source?:string)

//via


export type ConnectionProps = {
    connection:GraphNode|Graph|{[key:string]:any}|string, //can be a node, graph, connection Info object or _id string 
    service?:string|Graph|Service, //
    source?:string, //group of connections the connection belongs to, e.g. a user id or a service 
    onclose?:(connection:ConnectionInfo,...args:any[])=&gt;void
}
//valid connections: SocketInfo, SocketServerInfo, SSEChannelInfo, SSESessionInfo, EventSourceInfo, ServerInfo, WebRTCInfo

export type ConnectionInfo = {
    connection:GraphNode|Graph|{[key:string]:any}, //can be a node, graph, connection Info object or _id string 
    service?:string|Service|Graph,
    _id:string,
    source:string, // base connections can have multiple sources if you add the same connection again via addConnection with a new source specified!! These objects will be duplicated on each source container
    connectionType?:string, //if we know the key on the service we sourced an endpoint connection from, this helps with keeping track of things 
    connectionsKey?:string, //if we know the object on the service that the connection info is stored on
    send?:(message:any, ...a:any[])=&gt;any,
    request?:(message:any, method?:any,...a:any[])=&gt;Promise&lt;any&gt;|Promise&lt;any&gt;[],
    post?:(route:any, args?:any, method?:string, ...a:any[])=&gt;void,
    run?:(route:any, args?:any, method?:string, ...a:any[])=&gt;Promise&lt;any&gt;|Promise&lt;any&gt;[],
    subscribe?:(route:any, callback?:((res:any)=&gt;void)|string, ...a:any[])=&gt;Promise&lt;number&gt;|Promise&lt;number&gt;[]|undefined,
    unsubscribe?:(route:any, sub:number, ...arrayBuffer:any[])=&gt;Promise&lt;boolean&gt;|Promise&lt;boolean&gt;[],
    terminate:(...a:any[]) =&gt; boolean,
    onclose?:(connection:ConnectionInfo,...args:any[])=&gt;void
}
</code></pre>
<p>Or something like:</p>
<pre><code class="ts language-ts">router.addUser({_id:'me'},{socketId:'socket12345678'})

//which returns via promise:
export type User = { //users have macros to call grouped connections generically, based on what's available
    _id:string,
    send:(...args:any[])=&gt;any,
    request:(...args:any[])=&gt;Promise&lt;any&gt;|Promise&lt;any&gt;[]|undefined,
    post:(...args:any[])=&gt;void,
    run:(...args:any[])=&gt;Promise&lt;any&gt;|Promise&lt;any&gt;[]|undefined,
    subscribe:(...args:any[])=&gt;Promise&lt;number&gt;|Promise&lt;number&gt;[]|undefined,
    unsubscribe:(...args:any[])=&gt;Promise&lt;boolean&gt;|Promise&lt;boolean&gt;[]|undefined,
    terminate:(...args:any[]) =&gt; boolean,
    onclose?:(user:User)=&gt;void,
    [key:string]:any
} &amp; Partial&lt;ProfileStruct&gt;
</code></pre>
<p>The user's send/post/etc. handles will search available connections sourced to that user and use the best connection that has the available functionality based on matching methods. The services we have all follow the same straightforward, fully functional (including all of the source API features for each type of protocol still on-hand), and reproducible format for pooling and matching connections for easier high level integration and a fairly limited learning curve for the amount of features you can pack together in a few dozen lines. It's very performant, while you still have full control over your servers and services as you need deeper specifications.</p>
<p>All together now with sessions and mixed SSE + Websocket connections and a configurable http/https serverâ€¦ See backend.ts in <code>examples/webrtcrouter</code></p>
<pre><code class="ts language-ts">import { Router, User } from "../../services/router/Router";
import { SocketServerProps, WSSbackend } from "../../services/wss/WSS.node";
import { SSEbackend, SSEProps } from "../../services/sse/SSE.node";
import { HTTPbackend, ServerProps } from "../../services/http/HTTP.node";
import { SessionsService } from "../../services/streaming/sessions.service";
import { scriptBoilerPlate } from "../../services/http/boilerplate";

const router = new Router({
    services:{
        'sessions':SessionsService,
        'wss':WSSbackend,
        'sse':SSEbackend,
        'http':{
            service: HTTPbackend, //the router can instantiate the class for us
            config:{
                'server1':{
                    protocol:'http',
                    host:'localhost',
                    port:8080,
                    pages:{
                        '/':scriptBoilerPlate('dist/frontend.js'), //serve the built dist
                        'config':{
                            template:'tinybuild.config.js'
                        },
                        'home':{
                            redirect:'/'
                        },
                        'redir':{
                            redirect:'https://google.com'
                        },
                        'test':'&lt;div&gt;TEST&lt;/div&gt;',
                        _all:{
                            inject:{ //page building
                                hotreload:'ws://localhost:8080/hotreload' //this is a route that exists as dynamic content with input arguments, in this case it's a url, could pass objects etc in as arguments
                            }
                        }
                    },
                    onopen:(served)=&gt;{

                        router.openConnection(
                            'wss',
                            {
                                server:served.server,
                                host:served.host,
                                port:8081,
                                path:'wss',
                                onconnection:(ws,req,serverinfo,id)=&gt;{
                                    ws.send('Hello from WSS!');
                                }
                            } as SocketServerProps
                        )

                        router.openConnection(
                            'wss',
                            {
                                server:served.server,
                                host:served.host,
                                port:7000,
                                path:'hotreload',
                                onconnection:(ws)=&gt;{
                                    ws.send('Hot reload port opened!');
                                }
                            } as SocketServerProps
                        )

                        router.openConnection(
                            'sse',
                            {
                                server:served.server,
                                path:'sse',
                                channels:['test'],
                                onconnection:(session,sseinfo,id,req,res)=&gt;{
                                    console.log('pushing sse!')
                                    session.push('Hello from SSE!');
                                    sseinfo.channels.forEach(
                                        (c:string) =&gt; sseinfo.channel.broadcast(
                                            'SSE connection at '+req.headers.host+'/'+req.url, c 
                                        )
                                    );
                                }
                            } as SSEProps
                        )
                    }
                    // startpage:'index.html',
                    // errpage:undefined,
                    // certpath:'cert.pem', 
                    // keypath:'key.pem',
                    // passphrase:'encryption',
                } as ServerProps
            }
        }
    },
    loadDefaultRoutes:true,
    order:['sse','wss'],//prefer certain connection sources in a certain order, defaults to load order (if appropriate callbacks are available for subscription)
    syncServices:true
}); //on frontend we want to prefer wss first as sse is POST-reliant from browser

//router.services.sessions.users = router.users;

router.addUser({
    _id:'admin'
});

let session = (router.services.sessions as SessionsService).openSharedSession(
    {
        _id:'webrtcrooms',
        settings:{
            name:'webrtcrooms',
            propnames:{
                rooms:true //if these props are updated on the user object we'll return them
            }  
        }
    },
    'admin'
);

router.run('sessions.sessionLoop');

router.subscribe('addUser', (user:User) =&gt; {
    console.log('new user!', user._id)
    if(typeof user === 'object') {
        let joined = (router.services.sessions as SessionsService).joinSession('webrtcrooms', user._id);
        if(joined) {
            user.send({route:'joinSession',args:[joined._id,user._id,joined]})
        }
    }
});

//console.log('router nodes',router.nodes.keys(),'\n\n wss nodes',router.services.wss.nodes.keys())
</code></pre>
    <footer></footer>
</body>
</html>