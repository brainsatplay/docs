<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brains@Play Docs</title>
    <link rel=stylesheet href="./../../brainsatplay-docs/default.css"/>
    <link rel=stylesheet href="./../../static/custom.css"/>
    <link rel="icon" href="./../../static/img/favicon.ico" type="image/x-icon" />
</head>
<body>
    <div id="brainsatplay-docs">

    <header>
        <nav><h1>Brains@Play</h1></nav>
    </header>
    <div id="brainsatplay-docs-main">
        <div id="brainsatplay-docs-sidebar"><ul data-sidebar-depth=0><a href="./../../roadmap.html"><li>Home</li></a><li>Repos</li><ul data-sidebar-depth=1><a href="./../index.html"><li>Main  Page</li></a><li>Accessify</li><ul data-sidebar-depth=2><a href="./../accessify/index.html"><li>Main  Page</li></a></ul><li>Datastreams Api</li><ul data-sidebar-depth=2><a href="./../datastreams-api/index.html"><li>Main  Page</li></a></ul><li>Components</li><ul data-sidebar-depth=2><a href="./../components/index.html"><li>Main  Page</li></a></ul><li>Brainsatplay</li><ul data-sidebar-depth=2><a href="./../brainsatplay/index.html"><li>Main  Page</li></a><li>Src</li><ul data-sidebar-depth=3><li>Core</li><ul data-sidebar-depth=4><a href="./../brainsatplay/src/core/index.html"><li>Main  Page</li></a></ul></ul></ul><li>Docs</li><ul data-sidebar-depth=2><a href="./../docs/index.html"><li>Main  Page</li></a><li>Old</li><ul data-sidebar-depth=3><li>Docs</li><ul data-sidebar-depth=4><a href="./../docs/old/docs/index.html"><li>Main  Page</li></a><li>Guides</li><ul data-sidebar-depth=5><a href="./../docs/old/docs/guides/index.html"><li>Main  Page</li></a><li>Libraries</li><ul data-sidebar-depth=6><a href="./../docs/old/docs/guides/libraries/index.html"><li>Main  Page</li></a></ul></ul><li>Resources</li><ul data-sidebar-depth=5><a href="./../docs/old/docs/resources/Algorithms.html"><li>Algorithms</li></a><a href="./../docs/old/docs/resources/Biosignals.html"><li>Biosignals</li></a><a href="./../docs/old/docs/resources/BrainScience.html"><li>Brain Science</li></a><a href="./../docs/old/docs/resources/Electronics.html"><li>Electronics</li></a><a href="./../docs/old/docs/resources/ParticipatoryResearch.html"><li>Participatory Research</li></a><a href="./../docs/old/docs/resources/GeneralEngineering.html"><li>General Engineering</li></a><a href="./../docs/old/docs/resources/Psychology.html"><li>Psychology</li></a><a href="./../docs/old/docs/resources/index.html"><li>Main  Page</li></a><li>Hardware</li><ul data-sidebar-depth=6><a href="./../docs/old/docs/resources/hardware/Development.html"><li>Development</li></a><a href="./../docs/old/docs/resources/hardware/ECG.html"><li>ECG</li></a><a href="./../docs/old/docs/resources/hardware/EDA.html"><li>EDA</li></a><a href="./../docs/old/docs/resources/hardware/EEG.html"><li>EEG</li></a><a href="./../docs/old/docs/resources/hardware/EMG.html"><li>EMG</li></a><a href="./../docs/old/docs/resources/hardware/FNIRS.html"><li>FNIRS</li></a><a href="./../docs/old/docs/resources/hardware/Microscopy.html"><li>Microscopy</li></a><a href="./../docs/old/docs/resources/hardware/PPG.html"><li>PPG</li></a><a href="./../docs/old/docs/resources/hardware/index.html"><li>Main  Page</li></a></ul><li>Software</li><ul data-sidebar-depth=6><a href="./../docs/old/docs/resources/software/Applications.html"><li>Applications</li></a><a href="./../docs/old/docs/resources/software/C++.html"><li>C++</li></a><a href="./../docs/old/docs/resources/software/Javascript.html"><li>Javascript</li></a><a href="./../docs/old/docs/resources/software/Julia.html"><li>Julia</li></a><a href="./../docs/old/docs/resources/software/MATLAB.html"><li>MATLAB</li></a><a href="./../docs/old/docs/resources/software/Python.html"><li>Python</li></a><a href="./../docs/old/docs/resources/software/index.html"><li>Main  Page</li></a></ul></ul></ul></ul></ul><li>Escode</li><ul data-sidebar-depth=2><a href="./../escode/index.html"><li>Main  Page</li></a></ul><li>Graphscript</li><ul data-sidebar-depth=2><a href="./Graph.html"><li>Graph</li></a><a href="./Service.html"><li>Service</li></a><a href="./index.html"><li>Main  Page</li></a><li>Services</li><ul data-sidebar-depth=3><li>Cmd</li><ul data-sidebar-depth=4><a href="./services/cmd/cmd.service.html"><li>Cmd.service</li></a></ul><li>Dom</li><ul data-sidebar-depth=4><a href="./services/dom/dom.service.html"><li>Dom.service</li></a></ul><li>Http</li><ul data-sidebar-depth=4><a href="./services/http/http.browser.html"><li>Http.browser</li></a><a href="./services/http/http.node.html"><li>Http.node</li></a></ul><li>Sse</li><ul data-sidebar-depth=4><a href="./services/sse/sse.browser.html"><li>Sse.browser</li></a><a href="./services/sse/sse.node.html"><li>Sse.node</li></a></ul><li>Worker</li><ul data-sidebar-depth=4><a href="./services/worker/worker.html"><li>Worker</li></a><a href="./services/worker/worker.service.html"><li>Worker.service</li></a></ul><li>Router</li><ul data-sidebar-depth=4><a href="./services/router/Router.html"><li>Router</li></a></ul><li>Wss</li><ul data-sidebar-depth=4><a href="./services/wss/wss.browser.html"><li>Wss.browser</li></a><a href="./services/wss/wss.node.html"><li>Wss.node</li></a></ul><li>Webrtc</li><ul data-sidebar-depth=4><a href="./services/webrtc/webrtc.browser.html"><li>Webrtc.browser</li></a></ul></ul></ul><li>NRF52</li><ul data-sidebar-depth=2><a href="./../nRF52/index.html"><li>Main  Page</li></a></ul><li>Tinybuild</li><ul data-sidebar-depth=2><a href="./../tinybuild/index.html"><li>Main  Page</li></a><li>Tinybuild</li><ul data-sidebar-depth=3><li>Docs</li><ul data-sidebar-depth=4><a href="./../tinybuild/tinybuild/docs/esbuild.html"><li>Esbuild</li></a><a href="./../tinybuild/tinybuild/docs/python.html"><li>Python</li></a><a href="./../tinybuild/tinybuild/docs/server.html"><li>Server</li></a><a href="./../tinybuild/tinybuild/docs/tinybuild.html"><li>Tinybuild</li></a></ul></ul></ul><li>Visualscript</li><ul data-sidebar-depth=2><a href="./../visualscript/index.html"><li>Main  Page</li></a></ul><li>Wasl</li><ul data-sidebar-depth=2><a href="./../wasl/index.html"><li>Main  Page</li></a></ul></ul><li>Resources</li><ul data-sidebar-depth=1><a href="./../../resources/Algorithms.html"><li>Algorithms</li></a><a href="./../../resources/Biosignals.html"><li>Biosignals</li></a><a href="./../../resources/BrainScience.html"><li>Brain Science</li></a><a href="./../../resources/Electronics.html"><li>Electronics</li></a><a href="./../../resources/GeneralEngineering.html"><li>General Engineering</li></a><a href="./../../resources/ParticipatoryResearch.html"><li>Participatory Research</li></a><a href="./../../resources/Psychology.html"><li>Psychology</li></a><a href="./../../resources/index.html"><li>Main  Page</li></a><li>Hardware</li><ul data-sidebar-depth=2><a href="./../../resources/hardware/Development.html"><li>Development</li></a><a href="./../../resources/hardware/ECG.html"><li>ECG</li></a><a href="./../../resources/hardware/EDA.html"><li>EDA</li></a><a href="./../../resources/hardware/EEG.html"><li>EEG</li></a><a href="./../../resources/hardware/EIT.html"><li>EIT</li></a><a href="./../../resources/hardware/EMG.html"><li>EMG</li></a><a href="./../../resources/hardware/FNIRS.html"><li>FNIRS</li></a><a href="./../../resources/hardware/Microscopy.html"><li>Microscopy</li></a><a href="./../../resources/hardware/PPG.html"><li>PPG</li></a><a href="./../../resources/hardware/index.html"><li>Main  Page</li></a></ul><li>Software</li><ul data-sidebar-depth=2><a href="./../../resources/software/Applications.html"><li>Applications</li></a><a href="./../../resources/software/C++.html"><li>C++</li></a><a href="./../../resources/software/Development.html"><li>Development</li></a><a href="./../../resources/software/Javascript.html"><li>Javascript</li></a><a href="./../../resources/software/Julia.html"><li>Julia</li></a><a href="./../../resources/software/MATLAB.html"><li>MATLAB</li></a><a href="./../../resources/software/Python.html"><li>Python</li></a><a href="./../../resources/software/index.html"><li>Main  Page</li></a></ul></ul><li>Blog</li><ul data-sidebar-depth=1></ul><li>Guides</li><ul data-sidebar-depth=1><li>Examples</li><ul data-sidebar-depth=2><a href="./../../guides/examples/device.html"><li>Device</li></a><a href="./../../guides/examples/phaser.html"><li>Phaser</li></a></ul><li>Getting Started</li><ul data-sidebar-depth=2><a href="./../../guides/getting-started/application.html"><li>Application</li></a><a href="./../../guides/getting-started/blog.html"><li>Blog</li></a><a href="./../../guides/getting-started/component.html"><li>Component</li></a><a href="./../../guides/getting-started/conventions.html"><li>Conventions</li></a><a href="./../../guides/getting-started/installation.html"><li>Installation</li></a><a href="./../../guides/getting-started/realtime.html"><li>Realtime</li></a></ul><li>Proposals</li><ul data-sidebar-depth=2><a href="./../../guides/proposals/hightime.html"><li>Hightime</li></a></ul></ul></ul></div>

        <section id="brainsatplay-docs-content">
            <h1 id="services">Services</h1>
<p>See <a href="./Service.html#included-services">Included Services</a></p>
<p>Before reading and getting immediately confused by this alien API, scroll through the code in <a href="./index.html">Examples</a> for very clear, compelling implementatons that flex our feature sets.</p>
<p>Services extend Graphs to build on the idea of creating pluggable <a href="https://www.akana.com/resources/microservices-why-should-businesses-care">microservices</a> in a unified, componentized programming interface, and simplifies the amount of work required to implement increasing numbers of protocols with more syntax and functionality than we can normally remember. Building these instead as Services and following the general formula here can vastly speed up feature development and feature meshing. </p>
<p>The Service class extends the Graph class and adds additional methods for creating and linking execution graphs. All extended Services (WorkerService, HTTPbackend, etc) can load any other Services/Graphs/routes/etc. to serve as the entry point to your program depending on how you need to stage your programs. The only incompatibilities are based on nodejs or browser-specific functionality like command line or DOM access (without a document and window renderer in node anyway).</p>
<p>Services provide a unifying function/class loading and message passing framework to make it really easy to chain program functions across http, socket, sse, webrtc, thread, child process, frontend rendering and any of your own protocols. It has more features to help with scoping connected node services as well. </p>
<p>Create routed nodes with any functions, node/graph/service prototypes, any objects at all (e.g. the built in Math object in browsers) to gain state machine and flowgraph functionalities across your program, even remotely.</p>
<div class="brainsatplay-docs-code"><span>Code</span>
<pre><code>type RouteProp = { //these are just multiple methods you can call on a route/node tag kind of like http requests but really it applies to any function you want to add to a route object if you specify that method even beyond these http themed names :D
    get?:((...args:any)=&gt;any|void),
    post?:OperatorType|((...args)=&gt;any|void), 
    put?:(...args:any)=&gt;any|void,
    head?:(...args:any)=&gt;any|void,
    delete?:(...args:any)=&gt;any|void,
    patch?:(...args:any)=&gt;any|void,
    options?:(...args:any)=&gt;any|void,
    connect?:(...args:any)=&gt;any|void,
    trace?:(...args:any)=&gt;any|void,
    aliases?:string[] 
} &amp; GraphNodeProperties


type Routes = { //same as the tree in the base acyclic graph but adds aliases and RouteProps handling
    [key:string]:
        GraphNode |
        Graph | //special nodes, the graph will live on the .source property of this node and the operator accepts objects with key:value pairs to run functions on the graph and return a results object with corresponding key:value pairs.
        Service | 
        GraphNodeProperties |
        ((...args)=&gt;any|void) |
        { aliases?:string[] } &amp; GraphNodeProperties |
        RouteProp
}

//the input options are kind of complex but allow for robust programmatic customization. 
export type ServiceOptions = {
    routes?:Routes|Routes[], 
    name?:string, 
    props?:{[key:string]:any}, 
    loadDefaultRoutes?:boolean,
    includeClassName?:boolean,
    routeFormat?:string,
    customRoutes?:{ //modify routes or execute other functions based on the route properties? e.g. addElement in DOMService
        [key:string]:(route:Route, routeKey:string, routes:Routes)=&gt;Route|any|void
    },
    customChildren?:{ //modify child routes in the tree based on parent conditions
        [key:string]:(child:Route, childRouteKey:string, parent:Route, routes:Routes, checked:Routes)=&gt;Route|any|void
    },
    sharedState?:boolean, //share state between services? default is true, graphs have independent states at the base
    [key:string]:any
};


//these are the same as trees except they can turn get or post into operators,
// this makes more sense when the http server is involved but you can specify any
let routes:Routes = {
    add:{
        post:(a,b) =&gt; {
            return a+b;
        },
        aliases:['addition'] //these are in the base graph too as a feature
    }
}

const service = new Service({routes});

</code></pre></div>
<p>In a Service you declare <code>routes</code> instead of a <code>tree</code> (the 'tree' property is still functional internally but not used in the service's constructor), which adds customizable <a href="./Graph.html">GraphNodeProperties</a> for more advanced scripting, e.g. for DOM or Web Worker controls. The routes aim to multiplex the calls to GraphNodes the same way you can get/post/delete etc over single HTTP urls to on a REST api, or in our case calling any existing method (functions or e.g. stored html template strings) you specify on a route/node. Every service includes a set of optional default routes for basic operations like getting/setting/logging/subscribing/pinging/etc. so each service is self contained and works as the entry point to your program using whatever composition of services that have been loaded into it. </p>
<p>Services supply additional functions for piping the outputs of one function to others, including through to other services you've loaded into your main parent service interface. A lot of this is much better explained with code. The Router service works as an even more general service bundler for creating easy user and server pipelines.</p>
<p>Multiple services also support custom route formats which you can easily mirror when developing your own services with our object tree-based programmable systems. We spent a lot of time most notably on the DOM service which lets you quickly compose your web UI with HTML and heavily customizable web components. Support is expanding to include on-the-fly .md or .jsx format parsing, for example, which can include the needed scripts for you in-browser.</p>
<h2 id="service-messages">Service Messages</h2>
<p>For microservices to be able to talk to each other, we use a common set of keys in an object used for message passing and transmitting/receiving between services and nodes, including those on other servers or threads. </p>
<div class="brainsatplay-docs-code"><span>Code</span>
<pre><code>type ServiceMessage = {
    route?:string,  //the function/node to execute
    args?:any, //route args or data depending on what we're handling
    method?:string, //can specify get, post, etc. on http requests or on multiplexed routes using the RouteProp format
    node?:string|GraphNode, //alt tag for routes
    [key:string]:any //it's an object so do whatever, any messages meant for web protocols need to be stringified or buffered
}


let message:ServiceMessage = {route:'add', args:[10,20], method:'post'};

service.transmit(message); //these get customized in services representing their specific protocols e.g. http or websockets to deal with those specific interface requirements

</code></pre></div>
<p>All of the remote message passing services with two way communication channels (excluding http/sse currently) have the following functions available on each instance of your socket, rtc peer, worker thread (including worker-&gt;worker message ports), child process, etc. connections to make it really easy to build complex message passing functions e.g. for server or multiplayer communication and remote control. </p>
<div class="brainsatplay-docs-code"><span>Code</span>
<pre><code>
type ConnectionTemplate = {
    _id?:string,
    send?:(message:any, ...args:any[])=&gt;any,
    request?:(message:any, method?:any,...args:any[])=&gt;Promise&lt;any&gt;|Promise&lt;any&gt;[],
    post?:(route:any, args?:any, method?:string, ...args:any[])=&gt;void,
    run?:(route:any, args?:any, method?:string, ...args:any[])=&gt;Promise&lt;any&gt;|Promise&lt;any&gt;[],
    subscribe?:(route:any, callback?:((res:any)=&gt;void)|string, ...args:any[])=&gt;Promise&lt;number&gt;|Promise&lt;number&gt;[]|undefined,
    unsubscribe?:(route:any, sub:number, ...args:any[])=&gt;Promise&lt;boolean&gt;|Promise&lt;boolean&gt;[],
    terminate:(...args:any[]) =&gt; boolean,
    [key:string]:any //e.g. http server settings, or websocket paths, webrtc peer candidates, etc.
}

</code></pre></div>
<p>These services provide defaults for mostly zero config wiring up for programs, just specify ports, routes, ids, etc. as you need increasing control over your program. There are no restrictions on top of the base protocols, it's all just boiled down to one liners and similar calls between services for mental clarity and a recommended configuration by default to enable the most desirable functionality e.g. if you do not specify your own onmessage callbacks for sockets or threads then the default functions are set to interface with the graph/service architecture automatically for zero config if you stick to the main tag-based run/subscribe templates here. Everything in the base javascript tooling is available still for direct calls to save overhead - of which there is very little in our system here, ideally the bare minimum in each protocol to application maximize performance for general use cases.</p>
<p>The subscribe and unsubscribe functions act the same as they do locally and configure the endpoints with a state subscription on arbitrary routes for you to do what you want with on the listening port.</p>
<h1 id="included-services">Included Services</h1>
<p>We will elaborate on all of this with individual docs for each microservice, as they can go pretty deep. </p>
<p>For all services with remote message passing support (http, wss, sse, webrtc, etc.) they are by default configured to handle our service messages alongside arbitrary callbacks or basic standard functions (e.g. file serving in the http server). This allows them to be quickly wired together with your custom services without worrying about formats matching up.</p>
<ul>
<li><p>DOM - Create elements, detailed web components, or a macro for canvases that tie in with the graph. Really quickly script out whole web pages with heavy interactivity with a lot less fuss. Includes .md and .jsx interpreting options (rough). (browser only) </p>
<ul>
<li>- <a href="./services/dom/dom.service.html">DOMService</a></li></ul></li>
<li><p>HTTP - Create <a href="https://nodejs.org/api/http.html">http/https servers</a> and manage REST calls and create static or dynamic websites instantly. The server is set up to handle custom GET/POST requests using our route format encoded in the request body as well as standard GET/POST calls for serving files. The backend HTTP service allows you to construct webpages just from strings and inject code e.g. for hotreloading into your page with simple one liners. You can even build whole pages from lists of functions and template strings.</p>
<ul>
<li>- <a href="./services/http/http.node.html">HTTPbackend</a></li>
<li>- <a href="./services/http/http.browser.html">HTTPfrontend</a></li></ul></li>
<li><p>WSS - Websocket server frontend and backend to route service messages and for general use. It's a simple single function call to create the socket server on the backend with your http server and then open connections on the frontend. Leverages the small <a href="https://github.com/websockets/ws"><code>ws</code></a> library for nodejs. </p>
<ul>
<li>- <a href="./services/wss/wss.node.html">WSSbackend</a></li>
<li>- <a href="./services/wss/wss.browser.html">WSSfrontend</a></li></ul></li>
<li><p>Router - Arbitrary connection pooling using our templated connections</p>
<ul>
<li>- <a href="./services/router/Router.html">Router</a></li></ul></li>
<li><p>SSE - <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">Server-sent events</a> using <a href="https://www.npmjs.com/package/better-sse"><code>better-sse</code></a>, this allows for one way communication to connected clients. This api gives you handles for each client as well, so individuals can be messaged on a shared channel without notifying others. This has much less overhead when two way communication is unnecessary or when you can fire-and-forget message results.</p>
<ul>
<li>- <a href="./services/sse/sse.node.html">SSEbackend</a></li>
<li>- <a href="./services/sse/sse.browser.html">SSEfrontend</a></li></ul></li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Worker</a> - Multithreading is essential for high performance applications, and essentially all logic not running directly on the UI should be offloaded to workers in a production environment, so we handled the message passing system for you. In nodejs, threads can even run their entire own servers. In browser, they can handle canvas draw calls, sockets, REST calls, etc.  See examples for canvas, threejs, and entity component system samples.</p>
<ul>
<li>- <a href="./services/worker/worker.service.html">WorkerService</a></li>
<li>- <a href="./services/worker/worker.html">Workers</a></li></ul></li>
<li><p><a href="https://webrtc.org/">WebRTC</a> - Browser supported peer 2 peer streaming and data channels with <a href="https://webrtc.org/">WebRTC</a>. We can easily use the service and Router user framework to share room information or create remote commander/listener instances through a server.</p>
<ul>
<li>- <a href="./services/webrtc/webrtc.browser.html">WebRTCfrontend</a></li></ul></li>
<li><p>CMD - Command <a href="https://nodejs.org/api/child_process.html">child processes</a>, load processes that run their own CMD services to listen for cross-process service messages. This is the entry point for containerized applications with independent memory pools e.g. for rapid testing or for server multiplexing. (server only)</p>
<ul>
<li>- <a href="./services/cmd/cmd.service.html">CMDService</a></li></ul></li>
<li><p>Struct - Comprehensive data structure system for users. This includes basic access permissions, persistent notifications e.g. for chatroom data, and options to hook into MongoDB or basic local in-memory data maps for cloud server or frontend usage. </p></li>
<li><p>E2EE - End 2 End encryption made easy with the minimal <a href="https://crypto.stanford.edu/sjcl/">Stanford Javascript Cryptography Library</a>. It's set up to generate keys which you can copy to the desired endpoint (should do it securely) to pass encrypted service messages that automatically reroute through the encryption service. It can even encrypt the hash key table with a server side secret. </p></li>
<li><p>GPU - This service implements an instance of <a href="https://gpu.rocks/#/">gpu.js</a> via our <a href="https://github.com/joshbrew/gpujsutils"><code>gpujsutils</code></a> library, which is a stable gpu.js distribution and macro set. Kernels are created persistently on the gpu via webgl2 and i/o can be resized dynamically, so this runs as fast as Webgl2 allows. Hoping gpujs sees some upgrades for WebGPU as it lets you write shader code in plain loosely typed javascript!</p></li>
<li><p>ECS - <a href="https://github.com/SanderMertens/ecs-faq#what-is-ecs">Entity Component System</a> Service provides a simple spec to help you organize 'entities' with 'components' that tell different 'systems' to execute based on an execution order you provide. E.g. physics entities may have a collision system and a movement system before a final render system, and each entity will have values stored that get mutated by each system in an order that makes physical sense (e.g. check collision -&gt; update velocity -&gt; update position -&gt; update render each frame). This is a loose spec, the rest is provided by the base Service/Graph node composition tools to give you full flow graph and state management under the hood. </p></li>
<li><p>Unsafe - These let you dynamically transfer functions and classes or read/write global values across service instances, e.g. to other threads or between frontend/backend. Use with caution as it is reliant on eval(), but generally this is an easy way to generate and control entire backends and thread pools from a single file.</p></li>
</ul>
<p>This is all receiving constant updates and is not entirely tested. </p>
        </section>
    </div>
    <footer></footer>
    </div>
</body>
</html>